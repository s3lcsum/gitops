---
globs: *.tf
alwaysApply: false
---
# Terraform File Structure Guidelines

## Required File Structure
Always organize Terraform configurations with these specific files:

- **`main.tf`** - Primary infrastructure resources and configuration
- **`variables.tf`** - Variable declarations (especially for sensitive/secret values)
- **`locals.tf`** - Local values and computed expressions (heavily used for single-environment setups)
- **`providers.tf`** - Provider configurations with explicit version pins
- **`outputs.tf`** - Output values for external consumption (only create if you need to expose values from state)
- **`data.tf`** - Data source definitions
- **`default.auto.tfvars`** - Default variable values (automatically loaded)
- **`Makefile`** - Build automation with default targets (preferred over shell scripts)

## Script and Documentation Preferences
**‚ùå Avoid `.sh` scripts** - If you need to save instructions or setup commands, use `README.md` instead:
- Documentation in README is more discoverable and maintainable
- Shell scripts can become outdated and are ha
- README instructions can include context and explanations
- Use `Makefile` for automation tasks with proper default targets

**‚úÖ Use `Makefile` for automation:**
- Define default targets for common operations
- Include help target showing available commands
- Keep commands simple and well-documented
- Use `.PHONY` targets appropriately

## Provider Version Management
**NEVER use wildcard versions** - always specify explicit version numbers:

**‚úÖ Correct:**
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "5.40.0"  # Always specify exact latest version
    }
  }
}
```

**‚ùå Incorrect:**
```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"  # Never use version ranges
    }
  }
}
```

## Variable Usage Guidelines
**Use `variables.tf` primarily for sensitive/secret values:**
- API keys and tokens
- Database passwords
- Private keys and certificates
- Access credentials
- Internal URLs/endpoints

**‚úÖ Example:**
```hcl
variable "database_password" {
  description = "Database master password"
  type        = string
  sensitive   = true
}

variable "api_secret_key" {
  description = "API authentication secret"
  type        = string
  sensitive   = true
}
```

## Local Values Strategy
**Since this is single-environment focused, heavily use `locals.tf`:**
- Environment-specific configurations
- Computed resource names and identifiers
- Common tags and metadata
- Derived values from variables
- Resource configuration templates

**‚úÖ Example:**
```hcl
locals {
  environment = "production"
  region      = "us-west-2"

  common_tags = {
    Environment = local.environment
    Project     = "homelab"
    ManagedBy   = "terraform"
  }

  resource_prefix = "${local.environment}-${local.region}"
  database_name   = "${local.resource_prefix}-postgres"
}
```

## Module Creation Guidelines
**Only create modules when:**
- Main.tf would exceed 100 lines
- The module requires multiple resources (3+)
- Logic is truly reusable across environments
- Complexity justifies the abstraction

**‚ùå Don't create modules for:**
- Single resource abstractions
- Simple configurations under 100 lines
- One-off resources that won't be reused

## Resource Creation Best Practices
**Always prefer `for_each` over multiple similar resources:**

**‚úÖ Preferred (using for_each):**
```hcl
resource "aws_security_group" "services" {
  for_each = local.service_ports

  name_prefix = "${each.key}-sg-"
  description = "Security group for ${each.key}"

  ingress {
    from_port   = each.value.port
    to_port     = each.value.port
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
  }

  tags = merge(local.common_tags, {
    Service = each.key
  })
}
```

**‚ùå Avoid (multiple separate resources):**
```hcl
resource "aws_security_group" "web" {
  # ... configuration
}

resource "aws_security_group" "api" {
  # ... configuration
}

resource "aws_security_group" "database" {
  # ... configuration
}
```

## File Organization Best Practices
**Keep files focused and single-purpose:**
- `main.tf` - Core infrastructure (instances, networks, storage)
- `data.tf` - Data sources and lookups
- `outputs.tf` - Values to expose (IDs, endpoints, connection strings; only create if you need to expose values from state)
- `providers.tf` - Only provider configurations and terraform block

**Avoid mixing concerns within files** - each file should have a clear, single responsibility.

## Code Validation and Formatting Requirements
**ALWAYS validate and format code after any terraform modifications:**

### Required Validation Steps:
1. **Format Check**: Run `terraform fmt` to ensure consistent formatting
2. **Syntax Validation**: Run `terraform validate` to check for syntax and configuration errors
3. **Plan Validation**: Run `terraform plan` to verify resource configurations are valid

### Common Commands to Run:
```bash
# Format your code
terraform fmt

# Validate syntax and configuration
terraform validate

# Check if changes are valid (optional but recommended)
terraform plan
```

### Resource/Data Source Validation:
**‚ö†Ô∏è CRITICAL**: Always validate that resource and data source options match the provider version being used:

**‚úÖ Always verify provider documentation:**
- Resource arguments may change between versions
- Deprecated arguments may be removed
- New required arguments may be added
- Data source outputs may be modified

**‚ùå Common mistakes to avoid:**
- Using deprecated resource arguments
- Missing required arguments in newer provider versions
- Incorrect argument names due to API changes
- Using data source outputs that no longer exist

**üìã Validation checklist:**
- [ ] Run `terraform validate` after any code changes
- [ ] Check provider documentation for version-specific changes
- [ ] Verify all required arguments are present
- [ ] Ensure no deprecated arguments are used
- [ ] Test with `terraform plan` to catch configuration errors
